(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{387:function(s,e,n){"use strict";n.r(e);var t=n(5),a=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),e("p",[s._v("本文详细记录了一次在Kubernetes环境中Golang服务启动时出现OOM（Out of Memory）问题的排查和解决过程。服务在启动约2分钟后出现内存溢出，通过pprof工具分析发现主要问题源于bytes.Buffer对象的频繁扩容。")]),s._v(" "),e("h2",{attrs:{id:"现象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#现象"}},[s._v("#")]),s._v(" 现象")]),s._v(" "),e("p",[s._v("有一个golang后台服务跑在了k8s集群上，在启动过程中，大约 2 分钟后，该服务所在的pod出现了 OOM，也就是超过了部署该 POD 的 limit 内存大小。")]),s._v(" "),e("h2",{attrs:{id:"分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[s._v("#")]),s._v(" 分析")]),s._v(" "),e("p",[s._v("该现象是可复现的，所以我通过重启该pod，在其还没出现 OOM 时使用 pprof 将服务的 profile 文件给获取到。")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[s._v("curl")]),s._v(" http://localhost:8080/debug/pprof/heap "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-o")]),s._v(" profile\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("然后使用下面的命令在网页上查看服务的内存使用情况。")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("go tool pprof "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-http")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(":8081 profile\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("在网页上，在顶部的导航栏中，选择 View -> Top，SAMPLES -> alloc_space，来查看从服务启动时，申请内存Top。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/17585287225681758528722158.png",alt:"17585287225681758528722158.png"}})]),s._v(" "),e("p",[s._v("首先可以看到第一名申请的内存是 bytes.makeSlice，看名字大胆的猜测，是因为切片内存申请过多导致的，接下来需要验证。")]),s._v(" "),e("p",[s._v("选中该行，然后选择 View -> Graph，就会进入进入到一个函数调用链。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/17585288355611758528835189.png",alt:"17585288355611758528835189.png"}})]),s._v(" "),e("p",[s._v("我们先找到调用链的底端，可以看到 bytes.makeSlice 占用了1.12G 内存，调用者是 "),e("a",{attrs:{href:"https://github.com/golang/go/blob/d41a8222133aabaf5527eab64586050a0fbb773b/src/bytes/buffer.go#L126",target:"_blank",rel:"noopener noreferrer"}},[s._v("bytes(*Buffer).grow"),e("OutboundLink")],1),s._v("，通过源码分析是 Buffer 对象扩容导致的。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/17585294490741758529449060.png",alt:"17585294490741758529449060.png"}})]),s._v(" "),e("p",[s._v("通过调用链往上找到在业务代码上创建并使用 Buffer 对象的地方，最终找到了 Serialize 函数。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/17585295595181758529558760.png",alt:"17585295595181758529558760.png"}})]),s._v(" "),e("p",[s._v("我们看想该函数，该函数的作用是，将value对象序列化成byte数组。然后看到其创建了 Buffer 对象，并将 value 对象序列化存储到其中。")]),s._v(" "),e("div",{staticClass:"language-golang line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("func Serialize(value interface{}) ([]byte, error) {\n\t// gob.Register(value)\n\tbuf := bytes.Buffer{}\n\tif err := gob.NewEncoder(&buf).Encode(&value); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("但我们立马发现了问题，我们创建 Buffer{} 并没有指定其大小，可以看到其结构体也没有默认大小，当写入数据时，则会进行调用 grow 进行扩容。")]),s._v(" "),e("div",{staticClass:"language-golang line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("type Buffer struct {\n\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n\toff      int    // read at &buf[off], write at &buf[len(buf)]\n\tlastRead readOp // last read operation, so that Unread* can work correctly.\n}\n\nfunc (b *Buffer) Write(p []byte) (n int, err error) {\n\tb.lastRead = opInvalid\n\tm, ok := b.tryGrowByReslice(len(p))\n\tif !ok {\n\t\tm = b.grow(len(p))\n\t}\n\treturn copy(b.buf[m:], p), nil\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("p",[s._v("再结合业务进行分析，服务启动时会有大量的数据需要进行序列化，每次调用该函数都是创建一个未指定大小的 Buffer 对象，然后序列化时进行不断地扩容，从而导致内存迅速增加，从而导致 OOM。")]),s._v(" "),e("h2",{attrs:{id:"解决办法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[s._v("#")]),s._v(" 解决办法")]),s._v(" "),e("p",[s._v("使用 sync.Pool 来复用 Buffer 对象，并且在创建 Buffer 对象时指定一个合适的大小，这样就可以减少内存的申请从而避免了 OOM。")]),s._v(" "),e("div",{staticClass:"language-golang line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('// 缓冲区池，复用 bytes.Buffer 对象\nvar bufferPool = sync.Pool{\n\tNew: func() interface{} {\n\t\t// 预分配 1KB 容量，减少扩容次数\n\t\tbuf := make([]byte, 0, 1024)\n\t\treturn bytes.NewBuffer(buf)\n\t},\n}\n\nfunc Serialize(value interface{}) ([]byte, error) {\n\tif value == nil {\n\t\treturn nil, fmt.Errorf("input nil value")\n\t}\n\n\t// 从池中获取缓冲区\n\tbuf := bufferPool.Get().(*bytes.Buffer)\n\tdefer func() {\n\t\tbuf.Reset()\n\t\tbufferPool.Put(buf)\n\t}()\n\n\tencoder := gob.NewEncoder(buf)\n\tif err := encoder.Encode(&value); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 高效的字节切片克隆返回数据\n\treturn bytesClone(buf.Bytes()), nil\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br")])]),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),e("ol",[e("li",[s._v("在编码方面需要注意内存管理和对象复用对系统稳定性的重要性。")]),s._v(" "),e("li",[s._v("善于利用工具来辅助排查问题。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);