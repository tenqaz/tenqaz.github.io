(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{393:function(_,v,t){"use strict";t.r(v);var r=t(5),e=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_0-前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0-前言"}},[_._v("#")]),_._v(" 0. 前言")]),_._v(" "),v("p",[_._v("在单点故障后，我们需要保证服务不间断，所以需要使用冗余的副本提供集群服务，从而达到服务的高可用。redis 提供了主从库数据同步机制，从而保证数据副本的一致性，而主从库使用的是读写分离的机制。")]),_._v(" "),v("h2",{attrs:{id:"_1-读写分离模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-读写分离模式"}},[_._v("#")]),_._v(" 1. 读写分离模式")]),_._v(" "),v("p",[_._v("通过该模式构建多个数据副本，使用读写分离的方式")]),_._v(" "),v("ul",[v("li",[_._v("读操作: 主从库都可以进行读取。")]),_._v(" "),v("li",[_._v("写操作: 先写入到主库，在同步到从库。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/20210806172905.png",alt:""}})]),_._v(" "),v("p",[v("strong",[_._v("为什么要读写分离呢？")])]),_._v(" "),v("p",[_._v("如果从库也可以进行写操作，那么主从库在同一个 key 中存储的值可能会不一致，如果要保证一致性，需要通过加锁来解决，但这样会造成性能的损耗。")]),_._v(" "),v("p",[_._v("但如果只有主库写入，在同步给从库，则能保证所有实例中数据的一致性。")]),_._v(" "),v("h2",{attrs:{id:"_2-全量复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-全量复制"}},[_._v("#")]),_._v(" 2. 全量复制")]),_._v(" "),v("h3",{attrs:{id:"_2-1-主从库同步的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-主从库同步的过程"}},[_._v("#")]),_._v(" 2.1 主从库同步的过程")]),_._v(" "),v("p",[v("strong",[_._v("第一阶段")])]),_._v(" "),v("p",[_._v("从库向主库发送"),v("strong",[_._v("psync")]),_._v("命令进行数据同步，该命令包含主库的"),v("strong",[_._v("runID")]),_._v("和复制进度"),v("strong",[_._v("offset")])]),_._v(" "),v("ul",[v("li",[_._v("runID，每个实例自动生成的随机 ID，第一次从库不知道主库 runID，设置为?")]),_._v(" "),v("li",[_._v("offset，记录复制的进度，第一次进度设置为-1")])]),_._v(" "),v("p",[_._v("主库会回复 runID 和 offset 给从库")]),_._v(" "),v("p",[v("strong",[_._v("第二阶段")])]),_._v(" "),v("p",[_._v("主从第一次同步是采用全量复制的方式，主库生成 RDB 文件，然后发送给从库，从库清空当前数据再读入 RDB 文件完成第一次同步。")]),_._v(" "),v("p",[_._v("在生成 RDB 文件时，还是会有新的操作的会进行，为了保持数据的一致性，会将新的操作记录到 replication buffer 中。")]),_._v(" "),v("p",[v("strong",[_._v("第三阶段")])]),_._v(" "),v("p",[_._v("RDB 文件发送到从库后，再 "),v("code",[_._v("replication buffer")]),_._v(" 中的操作再发送给从库。")]),_._v(" "),v("h3",{attrs:{id:"_2-2-如何减少主从同步时-对主库的压力"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-如何减少主从同步时-对主库的压力"}},[_._v("#")]),_._v(" 2.2 如何减少主从同步时，对主库的压力?")]),_._v(" "),v("p",[v("strong",[_._v("主从同步有哪些压力？")])]),_._v(" "),v("ul",[v("li",[_._v("生成 RDB，这个操作会 fork 子进程，会阻塞主线程的正常请求。")]),_._v(" "),v("li",[_._v("传输 RDB，会占用主库的网络带宽")])]),_._v(" "),v("p",[v("strong",[_._v("主-从-从模式")])]),_._v(" "),v("p",[_._v("可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。由从库生成 RDB 再传输给从库，减少了主库的压力。")]),_._v(" "),v("p",[_._v("在主库全量复制之后，会维护一个长连接，后需的操作命令通过该连接同步给从库")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/20210807091817.png",alt:""}})]),_._v(" "),v("h2",{attrs:{id:"_3-增量复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-增量复制"}},[_._v("#")]),_._v(" 3. 增量复制")]),_._v(" "),v("p",[_._v("全量复制是通过生成 RDB 发送到从库然后进行读取后进行同步。我们知道生成 RDB 本身就是一个消耗 CPU 的操作，并且存在阻塞主线程的风险，所以我们需要尽量少的执行全量复制的操作。")]),_._v(" "),v("p",[_._v("所以在第一次使用 RDB 全量复制后，主从库会建立一个长连接，主库收到的新命令会再同步到从库，这样就避免频繁全量复制。")]),_._v(" "),v("p",[_._v("但是有一个风险点是，如果过程发生了网络中断或者阻塞，该如何解决？")]),_._v(" "),v("h3",{attrs:{id:"_3-1-增量复制的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-增量复制的过程"}},[_._v("#")]),_._v(" 3.1 增量复制的过程")]),_._v(" "),v("p",[_._v("当主从连接时，会将新的操作的命令写入 "),v("code",[_._v("replication buffer")]),_._v(" 和 "),v("code",[_._v("repl_backlog_buffer")]),_._v(" 缓冲区中")]),_._v(" "),v("p",[v("code",[_._v("repl_backlog_buffer")]),_._v(" 是一个环形缓冲区，主库会记录当前的偏移量 "),v("code",[_._v("master_repl_offset")]),_._v("，记录自己写到的位置，而从库在上面也有对应的偏移量 "),v("code",[_._v("slave_repl_offset")]),_._v("，记录自己正在读到的偏移量。")]),_._v(" "),v("p",[_._v("在恢复连接时，从库会通过 "),v("code",[_._v("psync")]),_._v(" 命令将自己的偏移量 "),v("code",[_._v("slave_repl_offset")]),_._v(" 发送给主库，主库会将 "),v("code",[_._v("slave_repl_offset")]),_._v(" 和 "),v("code",[_._v("master_repl_offset")]),_._v(" 之间的命令同步给从库即可。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/20210807093129.png",alt:""}})]),_._v(" "),v("p",[_._v("举了例子：\n主库和从库之间相差了 put d e 和 put d f 两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。\n"),v("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/20210807092929.png",alt:""}})]),_._v(" "),v("p",[_._v("因为 "),v("code",[_._v("replication buffer")]),_._v(" 是一个环形的缓存，当主从库长期断开时，是有可能被覆盖掉旧的数据，这个时候是会重新发起全量复制，主库根据从库发送的 "),v("code",[_._v("slave_repl_offset")]),_._v(" 来判断是增量还是全量的复制。")]),_._v(" "),v("p",[v("strong",[_._v("那为什么全量复制使用 RDB 而不是使用 AOF 呢？")])]),_._v(" "),v("ul",[v("li",[_._v("RDB 文件是经过压缩的二进制文件，AOF 文件是记录每一次的操作，包含对同一个 key 的多次冗余操作，文件比 RDB 要大的多，使用 AOF 可以减少带宽")]),_._v(" "),v("li",[_._v("RDB 是二进制数据，从库还原速度快。而 AOF 需要依次重放每一个命令，恢复速度慢。")])]),_._v(" "),v("h2",{attrs:{id:"_4-参考文章"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-参考文章"}},[_._v("#")]),_._v(" 4. 参考文章")]),_._v(" "),v("ul",[v("li",[_._v("本文主要是学习《极客时间-redis 核心技术与实战》专栏总结而来")])])])}),[],!1,null,null,null);v.default=e.exports}}]);