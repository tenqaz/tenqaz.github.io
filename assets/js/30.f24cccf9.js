(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{389:function(o,r,_){"use strict";_.r(r);var t=_(5),v=Object(t.a)({},(function(){var o=this,r=o._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[o._v("#")]),o._v(" 前言")]),o._v(" "),r("p",[o._v("一条数据在更新过程当中，如果中途 mysql crash 了，mysql 是如何保证数据的一致性和持久性的？在这个过程中 mysql 的日志系统起到了至关重要的作用。本文将会介绍 mysql 中的 undo log、redo log 和 bin log 在这其中的作用。")]),o._v(" "),r("h2",{attrs:{id:"buffer-pool"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool"}},[o._v("#")]),o._v(" buffer pool")]),o._v(" "),r("p",[o._v("在数据更新的时候，数据并不是实时同步到硬盘中，而是在一块缓存 buffer pool 中更新，如果缓存中没有查询到该数据，则从磁盘中加载到 buffer pool 中。")]),o._v(" "),r("p",[o._v("当然，缓存的作用是为了提高 IO 性能，可以通过将数据先保留在缓存中，然后在适当的时机，批量写入到硬盘中。")]),o._v(" "),r("p",[o._v("并且在查询数据时，先是从缓存中进行查询，不用去磁盘中查找，减少 IO 的操作，加快查询的速度。")]),o._v(" "),r("h2",{attrs:{id:"undo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[o._v("#")]),o._v(" undo log")]),o._v(" "),r("p",[o._v("我们知道 InnoDB 是支持事务的，在事务提交失败时，是会回滚到执行之前的状态，那么肯定是需要保存之前的状态才可以进行恢复的，这个就是通过 undo log 来实现的。")]),o._v(" "),r("p",[o._v("在数据写入 buffer pool 的同时会将更新前的数据保存在 undo log 中，通过该日志语句便可以在事务回滚时，恢复到之前的状态。")]),o._v(" "),r("h2",{attrs:{id:"redo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[o._v("#")]),o._v(" redo log")]),o._v(" "),r("h3",{attrs:{id:"redo-log-的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-的作用"}},[o._v("#")]),o._v(" redo log 的作用")]),o._v(" "),r("p",[o._v("再回到 buffer pool ，因为它是缓存，是在内存中，所有它的缺点也显而易见，那就是当服务器宕机中，缓存中的数据会丢失，那么 mysql 是如何保证数据的持久性呢？这个时候就要来介绍介绍 redo log 了。")]),o._v(" "),r("p",[o._v("在数据更新到 buffer pool 后，这个时候会将更新后的数据记录到 redo log buffer 中，这个也是一个缓存区，它当然也具备了缓存优缺点，并且默认是在提交事务的时候写入到 redo log 中，刷盘的策略可以根据 "),r("code",[o._v("innodb_flush_log_at_trx_commit")]),o._v(" 来设置")]),o._v(" "),r("ul",[r("li",[o._v("0，不刷入磁盘")]),o._v(" "),r("li",[o._v("1，立即刷入磁盘（默认）")]),o._v(" "),r("li",[o._v("2，先刷入到 os cache 中")])]),o._v(" "),r("p",[o._v("因为 redo log 是顺序写入，所以 IO 性能不会太差。")]),o._v(" "),r("p",[o._v("当 buffer pool 中的数据还没有写入到磁盘中时，发生了宕机，当 mysql 重启时，会读取已经持久化 redo log 中的数据，再恢复到 buffer pool 中。")]),o._v(" "),r("p",[o._v("在开启事务准备更新一条记录时，InnoDB 会先在 buffer pool 中更新数据，然后将更新后的数据记录到 "),r("code",[o._v("redo log buffer")]),o._v(" 中，这也是一个缓存。当然这个时候也是会发生宕机，但是没关系，如果该部分数据丢失，则认为该次事务提交失败，数据会恢复到之前的状态。")]),o._v(" "),r("h3",{attrs:{id:"redo-log文件结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log文件结构"}},[o._v("#")]),o._v(" redo log文件结构")]),o._v(" "),r("p",[o._v("redolog 是由多个固定大小的文件组成的一个环形结构，并在这个环形结构中不断的写入与覆盖的过程。\n"),r("img",{attrs:{src:"https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/16699026890611669902688907.png",alt:""}})]),o._v(" "),r("ul",[r("li",[o._v("write pos：记录当前的位置")]),o._v(" "),r("li",[o._v("checkpoint：当前要擦除的位置")])]),o._v(" "),r("p",[o._v("当有新的 redo log 写入时，从 wirte pos 位置往后写，而 check point 是上一次已经刷入磁盘的数据的位置，也是要不断的往后推进，然后将数据刷入磁盘中。")]),o._v(" "),r("h2",{attrs:{id:"binlog"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[o._v("#")]),o._v(" binlog")]),o._v(" "),r("p",[o._v("是在 mysql 层级记录的日志，主要是用于主从复制和数据恢复，可以通过某个时间的全量备份+binlog 来恢复到任意时间内的状态。")]),o._v(" "),r("p",[r("strong",[o._v("和 redo log 的区别")])]),o._v(" "),r("table",[r("thead",[r("tr",[r("th",[o._v("性质")]),o._v(" "),r("th",[o._v("redo log")]),o._v(" "),r("th",[o._v("bin log")]),o._v(" "),r("th")])]),o._v(" "),r("tbody",[r("tr",[r("td",[o._v("实现")]),o._v(" "),r("td",[o._v("innodb 独有实现")]),o._v(" "),r("td",[o._v("mysql server 层级实现，所有的引擎都可以使用")]),o._v(" "),r("td")]),o._v(" "),r("tr",[r("td",[o._v("内容")]),o._v(" "),r("td",[o._v("物理 log, 记录的是“在某个数据页上做了什么修改”")]),o._v(" "),r("td",[o._v("逻辑 log，给 ID=2 这一行的 c 字段加 1")]),o._v(" "),r("td")]),o._v(" "),r("tr",[r("td",[o._v("写入")]),o._v(" "),r("td",[o._v("循环写入")]),o._v(" "),r("td",[o._v("追加写，写到一定大小切换下一个文件继续写")]),o._v(" "),r("td")]),o._v(" "),r("tr",[r("td",[o._v("应用")]),o._v(" "),r("td",[o._v("崩溃恢复(crash-safe)")]),o._v(" "),r("td",[o._v("主从同步，数据恢复")]),o._v(" "),r("td")])])]),o._v(" "),r("h2",{attrs:{id:"两阶段提交"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交"}},[o._v("#")]),o._v(" 两阶段提交")]),o._v(" "),r("p",[r("strong",[o._v("为什么需要两阶段提交？")])]),o._v(" "),r("p",[o._v("是为了让 redo log 和 bin log 保持逻辑一致性。")]),o._v(" "),r("ol",[r("li",[o._v("如果先写 redolog 后写 bin log。假设 redo log 写完，写 bin log 时 crash 了。")])]),o._v(" "),r("p",[o._v("因为 redo log 写完了，所以即使系统崩溃，也可以恢复数据，但是 bin log 没写完 crash 了，这个时候 bin log 中少了该条语句，因此数据备份的时候，如果使用了该份 bin log 则会少一次更新。")]),o._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[o._v("如果先写 bin log 后写 redo log。假设 bin log 写完，写 redo log 时 crash 了。")])]),o._v(" "),r("p",[o._v("因为 redo log 没写完，所以该事务没有生效，但是 binlog 中已经有该条记录，所以使用 bin log 时，会多出一个事务，与原来的数据不一致。")]),o._v(" "),r("p",[o._v("所以使用两阶段提交可以解决上面两种场景。")]),o._v(" "),r("p",[r("strong",[o._v("两阶段提交的实现逻辑")])]),o._v(" "),r("ol",[r("li",[o._v("在更新数据时，会先在 redo log 中记录当前更新的数据，并且标记为 prepare 状态")]),o._v(" "),r("li",[o._v("binlog 再进行写入")]),o._v(" "),r("li",[o._v("事务提交时， redo log 再将该条记录标记为 commit 状态并且刷入到磁盘中。")])]),o._v(" "),r("p",[o._v("通过 prepare 和 commit 两种状态来完成两阶段的提交实现。")]),o._v(" "),r("p",[r("strong",[o._v("验证两阶段提交")])]),o._v(" "),r("ol",[r("li",[o._v("如果在两阶段提交的第一步后发生 crash，也就是 redo log 已经更新了数据并且为 Prepare 状态，但是 binlog 还未写入就出现了 crash，这个时候，mysql 重启后，因为 redo log 未 commit，可以通过回滚将数据恢复。")]),o._v(" "),r("li",[o._v("如果在第二步发生 crash，也就是 redo log 为 prepare 状态，并且 binlog 已经写入，但是这时候出现了 crash，在 mysql 重启后，因为 binlog 已经有了记录，所以会继续提交该事务，否则 bin log 中数据新增了一条，而 redo log 没提交则可能发生两者数据不一致的情况。")])]),o._v(" "),r("h2",{attrs:{id:"相关链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相关链接"}},[o._v("#")]),o._v(" 相关链接")]),o._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html",target:"_blank",rel:"noopener noreferrer"}},[o._v("一条 SQL 的执行过程详解"),r("OutboundLink")],1)]),o._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6921898379555373064",target:"_blank",rel:"noopener noreferrer"}},[o._v("基于Redo Log和Undo Log的MySQL崩溃恢复流程"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=v.exports}}]);